package pdh.ui{			/**		UIOBject		-adds useful properties and methods for movieclips such as tweening.				- note: the Event.RENDER event is only fired with flash 9 update 3 in wmode:transparent.				Event.ADDED_TO_STAGE is only available with flash 9.0.28.				You cannot call stage.invalidate() WHILE executing code that was triggered from an Event.RENDER.	*/		import flash.display.MovieClip;	import flash.events.Event;		import flash.geom.Point;	import flash.utils.Dictionary;		public class UIObject extends MovieClip	{				protected var w				:Number;		protected var h				:Number;		protected var _isVisible	:Boolean = true;		private var _changed		:Boolean;				public function UIObject()		{			this.stop();		}						public function show():void 		{			if (_isVisible) return;			_isVisible = true;		}						public function hide():void 		{			if (!_isVisible) return;			_isVisible = false;		}						private var callLaterMethods:Dictionary = new Dictionary();		protected function callLater(fn:Function):void 		{			if (callLaterMethods[fn] == true){				//trace("[UIObject] method already called!")				return; // already called and hasnt rendered yet			}						//trace("[UIObject] calling method later")						callLaterMethods[fn] = true;			if (stage != null) {					stage.addEventListener(Event.ENTER_FRAME,callLaterDispatcher,false,0,true);					stage.addEventListener(Event.RENDER,callLaterDispatcher,false,0,true);					stage.invalidate();			} else {					addEventListener(Event.ADDED_TO_STAGE,callLaterDispatcher,false,0,true);			}		}				private function callLaterDispatcher(event:Event):void 		{						//trace(this + "[UIObject] call later dispatcher "  + event.type)						if (event.type == Event.ADDED_TO_STAGE) {					removeEventListener(Event.ADDED_TO_STAGE,callLaterDispatcher);					stage.addEventListener(Event.ENTER_FRAME,callLaterDispatcher,false,0,true);					// now we can listen for render event:					stage.addEventListener(Event.RENDER,callLaterDispatcher,false,0,true);					stage.invalidate();						return;			} else {					event.target.removeEventListener(Event.ENTER_FRAME,callLaterDispatcher);					event.target.removeEventListener(Event.RENDER,callLaterDispatcher);					if (stage == null) {							// received render, but the stage is not available, so we will listen for addedToStage again:							addEventListener(Event.ADDED_TO_STAGE,callLaterDispatcher,false,0,true);							return;					}			}			var methods:Dictionary = new Dictionary();			for (var copyMethod:Object in callLaterMethods) {					methods[copyMethod] = callLaterMethods[copyMethod];					delete(callLaterMethods[copyMethod]);			}			for (var method:Object in methods) {					method();			}		}						public function disposeMethod():void 		{			removeEventListener(Event.ADDED_TO_STAGE,callLaterDispatcher);			stage.removeEventListener(Event.ENTER_FRAME,callLaterDispatcher);			stage.removeEventListener(Event.RENDER,callLaterDispatcher);		}						//__________________________________________________________________________Properties								public function get isVisible():Boolean 		{			return _isVisible;		}				public function set isVisible(val:Boolean):void 		{			_isVisible = val;		}						///------------bottom				public function get bottom():Number		{			return this.y +  this.getBounds(this).bottom;		}				public function set bottom(val:Number):void		{			this.y  = val - this.getBounds(this).bottom;		}						///------------top				public function get top():Number		{			return this.y +  this.getBounds(this).top;		}				public function set top(val:Number):void		{			this.y  = val - this.getBounds(this).top;		}						///------------right				public function get right():Number		{			return this.x +  this.getBounds(this).right;		}				public function set right(val:Number):void		{			this.x  = val -  this.getBounds(this).right;		}				///------------left				public function get left():Number		{			return this.x + this.getBounds(this).x;		}				public function set left(val:Number):void		{			this.x  = val - this.getBounds(this).x;		}					//				public function get globalX():Number 		{			var point:Point =  this.localToGlobal(new Point(this.x, this.y))			return point.x - this.x		} 				public function set globalX(val:Number):void 		{			var point:Point =  this.globalToLocal(new Point(val, 0))			this.x = this.x +  point.x;		}				//				public function get globalY():Number 		{			var point:Point =  this.localToGlobal(new Point(this.x, this.y))			return point.y - this.y		} 				public function set globalY(val:Number):void 		{			var point:Point =  this.globalToLocal(new Point(0, val))			this.y = this.y + point.y		}						public function destroy():void 		{			disposeMethod()		}						// universal support		public function dispose():void 		{			destroy()		}							} // end class	} // end package