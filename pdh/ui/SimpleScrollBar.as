/**	required movieclips:		drag_mc	track_mc*/package pdh.ui{	import flash.display.Stage;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.geom.Rectangle;	import pdh.events.ScrollBarEvent;	import pdh.ui.UIObject;	import gs.TweenLite;	import gs.easing.*		public class SimpleScrollBar extends UIObject	{				private var scroll_rect:Rectangle;		private var upper_limit:Number;		private var range:Number;				protected var tweenEnabled:Boolean = true;				protected var dragging:Boolean = false;				// required movieclips		public var drag_mc	:Sprite;		public var track_mc	:Sprite; 				protected var speed		:Number = .5		//				public var horz		:Boolean = false;				public function SimpleScrollBar(_val:Boolean = false)		{			horz = _val			init();		}				public function setSpeed(val:Number):void 		{			speed = val;		}				private function init():void		{			drag_mc.buttonMode = true;			drag_mc.mouseChildren = false			drag_mc.addEventListener( MouseEvent.MOUSE_DOWN, press_drag ,false,0,true)						track_mc.buttonMode = true;			track_mc.mouseChildren = false			track_mc.addEventListener( MouseEvent.CLICK, click_track ,false,0,true)			set_limits();		}						public function recalculate():void 		{			drag_mc.removeEventListener( MouseEvent.MOUSE_DOWN, press_drag)			track_mc.removeEventListener( MouseEvent.CLICK, click_track)			init()		}				private function press_drag( event:Event ):void		{			dragging = true;			/***************************************************/			drag_mc.stage.addEventListener( MouseEvent.MOUSE_UP, release_drag, false, 0, true );			drag_mc.stage.addEventListener( Event.MOUSE_LEAVE, release_drag, false, 0, true );			/***************************************************/ 			drag_mc.startDrag( false, scroll_rect );			drag_mc.addEventListener( Event.ENTER_FRAME, drag ,false,0,true)		}				private function release_drag( event:Event ):void		{			dragging = false;			drag_mc.removeEventListener( Event.ENTER_FRAME, drag );			drag_mc.stage.removeEventListener( MouseEvent.MOUSE_UP, release_drag );			drag_mc.stage.removeEventListener( Event.MOUSE_LEAVE, release_drag);			drag_mc.stopDrag();		}				private function click_track( event:Event ):void 		{			var p:Number;			if (horz){				p = (track_mc.mouseX * track_mc.scaleX) / track_mc.width;			} else {				p = (track_mc.mouseY * track_mc.scaleY) / track_mc.height;			} 						trace( "Click track" + p);						//setValue(p);			tweenTo(p);					}				private function set_limits():void		{			if (horz){				scroll_rect = new Rectangle( track_mc.x, 0, track_mc.width - drag_mc.width, 0 );				upper_limit = track_mc.x;				range = track_mc.width - drag_mc.width;			} else {				scroll_rect = new Rectangle(0, track_mc.y, 0, track_mc.height - drag_mc.height );				upper_limit = track_mc.y;				range = track_mc.height - drag_mc.height;			}						if (range < 0) {				visible = false			} else {				visible = true;			}						trace("range = " + range);					}				// moves (tweens) a number of pixels		public function moveSlider(val:Number){			var v = drag_mc.x+ val;			if (v < upper_limit){				v = upper_limit							} else if (v > range){				v =range			}			TweenLite.to(drag_mc, speed, {x:v, onUpdate:updateAutoSlider})				}						private function updateAutoSlider():void 		{			drag();		}						private function drag(e:Event  = null):void		{			var p:Number;			if (horz){				p = ( drag_mc.x - track_mc.x ) / range;			} else {				p = ( drag_mc.y - track_mc.y ) / range;						}			dispatchEvent( new ScrollBarEvent( ScrollBarEvent.UPDATE, p ) );		}				public function reset():void 		{						var p:Number = 0;						if (horz){				drag_mc.x = track_mc.x;			} else {				drag_mc.y = track_mc.y;			}			dispatchEvent( new ScrollBarEvent( ScrollBarEvent.UPDATE, p ) );		}						// returns current percentage of where the slider is		public function getValue():Number{			if (horz){				return ( drag_mc.x - track_mc.x ) / range;			} else {				return ( drag_mc.y - track_mc.y ) / range;			}					}				public function setValue(val:Number):void		{			trace(val)						if (horz){				drag_mc.x = Math.round((val * range) + track_mc.x);			} else {				drag_mc.y = Math.round((val * range) + track_mc.y);			}		}				public function tweenTo(val:Number):void		{			trace(val)			var targX:Number;			var targY:Number;			if (tweenEnabled){				if (horz){					targX = Math.round((val * range) + track_mc.x);					TweenLite.to(drag_mc, .5, {x:targX, onUpdate:dispatchLocation, onComplete:dispatchLocation});				} else {					targY = Math.round((val * range) + track_mc.y);					TweenLite.to(drag_mc, .5, {y:targY, onUpdate:dispatchLocation, onComplete:dispatchLocation});				}			} else {				if (horz){					targX = Math.round((val * range) + track_mc.x);					drag_mc.x = targX				} else {					targY = Math.round((val * range) + track_mc.y);					drag_mc.y = targY				}				dispatchLocation()			}		}				private function dispatchLocation():void 		{			dispatchEvent( new ScrollBarEvent( ScrollBarEvent.UPDATE, getValue() ) );		}					}}