package pdh.modestmaps{	import gs.TweenLite;	import gs.easing.*;	import flash.net.URLRequest;		import flash.display.Loader;	import flash.events.Event;	import pdh.ui.UIObject;	import pdh.math.MathExtra;	import flash.display.MovieClip;	import com.modestmaps.TweenMap;	import com.modestmaps.events.MapEvent;	import com.modestmaps.core.TileGrid;	import com.modestmaps.geo.Location;	import pdh.modestmaps.ZoomifyProvider;	import com.modestmaps.core.MapExtent;	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.geom.Point;	import pdh.util.XMLLoader;	import pdh.ui.ZoomControls	import pdh.events.ZoomEvent;	import pdh.modestmaps.ZoomTile;	import flash.utils.getDefinitionByName;		public class ZoomifyViewer extends UIObject	{				private var zoomSteps				:int = 5;		private var zoomDistance			:Number = 5;				public static const LOADED			:String = "loaded";			public static const TWEEN_DONE		:String = "tween done";					private static const CONFIG_FILE	:String = "ImageProperties.xml";				private var fullImageWidth			:Number;		private var fullImageHeight			:Number;				public var zoomControls				:ZoomControls;		private var tileViewer				:TweenMap		private var dir						:String;		private var externalControls		:Boolean = false;		private var minzoom					:Number;		private var fitToSize				:Boolean;				var extent							:MapExtent		var north		var east		var south		var west				private var environmentVars			:Object;				function ZoomifyViewer(_w:Number, _h:Number, _fitToSize:Boolean = false, _controls:ZoomControls = null)		{			w = _w;			h = _h;			fitToSize = _fitToSize;						if (_controls != null)				init(_controls);			addListeners();		}						public function setEnvironmentVars(vars:Object):void 		{			environmentVars = vars;		}				// pass in pixel extents on orignial image size		public function setPixelExtent(obj:Object):void 		{			if (tileViewer == null) return;						// pixel values need to be discovered						var _north = (obj.y1 / fullImageHeight) * north			var _east = (obj.x2 / fullImageWidth) * east			var _west = (obj.x1 / fullImageWidth) * west			var _south = (obj.y2 / fullImageHeight) * south			        	extent = new MapExtent(_north, _south,  _east, _west)			trace("setting extent to :" +  extent)						//n:Number=0, s:Number=0, e:Number=0, w:Number=0			tileViewer.setExtent(extent);		}				// pass in pixel extents on orignial image size		public function setExtent(obj:Object):void 		{			if (tileViewer == null) return;						// pixel values need to be discovered						var _south = obj.y1			var _east = obj.x2			var _west = obj.x1			var _north = obj.y2						trace("y2:" +obj.y2 + " y1:" +obj.y1 +  " x2:" + obj.x2 + " x1:" + obj.x1)			        	extent = new MapExtent(_north, _south,  _east, _west)						trace("setting extent to :" +  extent)						//n:Number=0, s:Number=0, e:Number=0, w:Number=0			tileViewer.setExtent(extent);		}						public function setCenterZoom(_p:Point, _z:Number):void 		{			tileViewer.setCenterZoom(new Location(_p.x, _p.y), _z)		}								public function get tileMap():TweenMap		{			return tileViewer;		}				private function init(_controls:ZoomControls):void 		{			if (_controls != null){				zoomControls = _controls;				externalControls = true;			} else {				zoomControls = new ZoomControls();			}			addChild(zoomControls);		}				private function addListeners():void 		{			if (zoomControls != null){				zoomControls.addEventListener(ZoomEvent.ZOOM_IN, handleZoom, false, 0, true);				zoomControls.addEventListener(ZoomEvent.ZOOM_OUT, handleZoom, false, 0, true);				zoomControls.addEventListener(ZoomEvent.ZOOM_TO, handleZoom, false, 0, true);			}		}						private function handleZoom(e:ZoomEvent):void 		{			switch(e.type){				case ZoomEvent.ZOOM_IN:					trace("in")					zoomIn();					break;				case ZoomEvent.ZOOM_OUT:					trace("out")					zoomOut();					break;				case ZoomEvent.ZOOM_TO:									TweenLite.killTweensOf(zoomControls)										trace("zoom to " + e.parameters.value + " | " + zoomDistance + " | " + minzoom + " | " + tileViewer.grid.maxZoom)										//tileViewer.setZoom( (e.parameters.value * zoomSteps ) + minzoom)										var newvalue:Number =  (e.parameters.value * (zoomDistance) ) + (minzoom)										setZoom(newvalue)					break;			}		}				/*private function handleDoubleClick(e:MouseEvent){			trace(e);			//zoomIn();			tileViewer.pointLocation();			tileViewer.panAndZoomIn( null , {x:10, y:10} as Point   )		}*/				public function load(file:String):void 		{			dir = file;			var config_xml:XMLLoader =  new XMLLoader(dir + CONFIG_FILE);			config_xml.addEventListener(XMLLoader.LOADED, handleConfigLoaded, false, 0, true);		}				private function handleConfigLoaded(e:Event):void 		{			var xmlNodes:Object = e.target.xml;			fullImageWidth = Number(xmlNodes.@WIDTH.toString())			fullImageHeight = Number(xmlNodes.@HEIGHT.toString())						var provider =  new ZoomifyProvider(dir,fullImageWidth , fullImageHeight)			tileViewer = new TweenMap(w, h, true, provider );						// change some environment variables if they exist			if (environmentVars != null){				if (environmentVars.hasOwnProperty("maxOpenRequests")){					tileViewer.grid.maxOpenRequests = environmentVars.maxOpenRequests 				}				if (environmentVars.hasOwnProperty("cacheLoaders")){					TileGrid.cacheLoaders = environmentVars.cacheLoaders				}				if (environmentVars.hasOwnProperty("maxLoaderCacheSize")){					TileGrid.maxLoaderCacheSize = environmentVars.maxLoaderCacheSize				}			}							tileViewer.buttonMode = true;			//tileViewer.doubleClickEnabled = true;			tileViewer.addEventListener(MouseEvent.DOUBLE_CLICK, tileViewer.onDoubleClick, false, 0, true);			tileViewer.addEventListener(MapEvent.ZOOMED_BY, handleMapChange, false, 0, true);			tileViewer.addEventListener(MapEvent.STOP_ZOOMING, handleMapChange, false, 0, true);			tileViewer.zoomDuration = .5;						//trace(tileViewer.grid);									configureZoomLimit();						//trace(tileViewer.getWidth());			//tileViewer.grid.setTileClass(tileClass as Class)			addChild(tileViewer);						if (zoomControls != null)				if (!externalControls) zoomControls.y = h;										extent = tileViewer.getExtent()			trace("***")			trace("INITAL EXTENT = " + extent)			trace("***")			north = extent.north			east = extent.east			west = extent.west			south = extent.south												dispatchEvent(new Event(LOADED));			//TweenLite.from(ldr, .2, {alpha:0})		}				// ----------------------------------------------------------------- SETTING ZOOM MAX AND MIN				private function configureZoomLimit():void 		{			//fitToSize = true			// set min zoom to current zoom			if (fitToSize){				minzoom = getMinZoom()			} else {				minzoom = tileViewer.getZoom();			}						//Debug.alert("minzoom == "+minzoom)						tileViewer.grid.minZoom = minzoom;						zoomDistance = (tileViewer.grid.maxZoom - minzoom)			trace("ZOOM DISTANCE = " + zoomDistance)			trace("MAX = " + tileViewer.grid.maxZoom)			trace("MIN = " + minzoom)						zoomSteps = Math.floor(zoomDistance);						if (zoomControls != null)				zoomControls.update(0) // set controls to fully zoomed out		}				//fullImageHeight		//fullImageWidth		private function getMinZoom():Number 		{			var val:Number;			// horizontal photo			if (w > h){				if (fullImageHeight < fullImageWidth){					val = fitToWidth()				} else {					val = fitToHeight()				}			}			// vertical photo			else {				if (fullImageHeight > fullImageWidth){					val = fitToHeight()				} else {					val = fitToWidth()				}			}			return val;		}				private function fitToWidth():Number 		{			return fitPropToSize(fullImageWidth, w)		}				private function fitToHeight():Number 		{			return fitPropToSize(fullImageHeight, h)		}				private function fitPropToSize(va1:Number, val2:Number):Number 		{			var c:Number = tileViewer.grid.maxZoom - tileViewer.getZoom()			var q = va1 >> c			//Debug.alert((val2/q) + " fit to width " + q + " original zoom = " + tileViewer.getZoom())						var mz:Number			if (tileViewer.getZoom() == 0){				 mz = Math.abs( 1 - (val2/q))			} else {				 mz =  (val2/q)*tileViewer.getZoom()			}						return mz;		}						// ----------------------------------------------------------------- ZOOM TWEENING				var zoomToObject:Object;			const ZOOMTO_TWEENTIME:Number = 3		public function zoomToCenter(center:Point, _zoom:Number, speed:Number = 0)		{						trace("[ZoomifyViewer] Zoom To Center")						if (speed == 0) speed = ZOOMTO_TWEENTIME;						zoomToObject = new Object()						// get current zoom			zoomToObject.zoom = tileViewer.getZoom()						// get current center			var c_center =  tileViewer.getCenter()			zoomToObject.x = c_center.lat			zoomToObject.y = c_center.lon						TweenLite.to(zoomToObject, ZOOMTO_TWEENTIME, {overwrite:1, zoom:_zoom, x:center.x, y:center.y, onUpdate:zoomToTweening, onComplete:zoomToDone})		}				private function zoomToTweening():void 		{			tileViewer.setCenterZoom(new Location(zoomToObject.x, zoomToObject.y), zoomToObject.zoom)		}				private function zoomToDone():void 		{			dispatchEvent(new Event(TWEEN_DONE));		}				// ----------------------------------------------------------------- INSTANT ZOOMING				public function zoomIn():void 		{			var targetZoom:Number = zoomControls.currentZoom + .25			if (targetZoom > 1) targetZoom =1						TweenLite.to(zoomControls, 1, {overwrite:1, currentZoom:targetZoom, onUpdate:zoomToTweening})		}				public function zoomOut():void 		{			var targetZoom:Number = zoomControls.currentZoom - .25			if (targetZoom < 0) targetZoom =0						TweenLite.to(zoomControls, 1, {overwrite:1, currentZoom:targetZoom, onUpdate:zoomTweening})		}				private function zoomTweening(val:Number = -1):void 		{			if (val == -1) val = zoomControls.currentZoom			setZoom((val * zoomDistance) + minzoom)		}				private function setZoom(val:Number):void 		{			if (val < minzoom){				val = minzoom			} else if (val > tileViewer.grid.maxZoom){				val == tileViewer.grid.maxZoom;			}			tileViewer.setZoom(val )		}				// -----------------------------------------------------------------				private function updateControls():void 		{			var realzoom:Number = (tileViewer.getZoom() - (minzoom)) 						//Debug.alert("--> " + tileViewer.getZoom() + " | " + minzoom)						if  (realzoom > zoomDistance){				realzoom = zoomDistance;			} 						if (zoomControls != null)				zoomControls.update(realzoom / zoomDistance)		}				private function handleMapChange(e:MapEvent):void 		{			updateControls()		}				public function moveControlsTo(spr:Sprite):void 		{			externalControls	 = true;			zoomControls.y = 0;			zoomControls.x = 0;			spr.addChild(zoomControls);		}				public override function destroy():void		{			try{				if (contains(tileViewer)) removeChild(tileViewer);				tileViewer.removeEventListener(MouseEvent.DOUBLE_CLICK, tileViewer.onDoubleClick)				tileViewer.removeEventListener(MapEvent.START_ZOOMING, handleMapChange);				tileViewer.removeEventListener(MapEvent.ZOOMED_BY, handleMapChange);				tileViewer = null;				trace("!!!! destroy = " + tileViewer) 			} catch(err){};		}						public function setSize(_w:Number, _h:Number):void 		{			w = _w;			h = _h;						if (tileViewer != null){				tileViewer.setSize(w, h)				configureZoomLimit();				updateControls()			}					}					}	}