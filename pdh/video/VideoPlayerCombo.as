/**	requires FLVPlayback component		controls and video window managed in one class*/package pdh.video{	import gs.TweenMax;	import gs.easing.*;	import fl.video.*;	import flash.net.SharedObject;	import pdh.video.FLVPlaybackDispose;	import pdh.ui.UIObject;	import pdh.events.VideoPlayerEvent;	import pdh.video.VideoControls;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.MouseEvent;	import gs.TweenLite;	import gs.easing.*;	import flash.text.TextField;	import pdh.graphics.Box;	import flash.external.ExternalInterface;	import pdh.util.PhotoViewer;	import pdh.events.VideoControlsEvent;	import pdh.text.TextHelper;	import flash.media.SoundTransform;		public class VideoPlayerCombo extends UIObject	{				private static var browserURL	:String;		public static const SEEKING		:String = VideoState.SEEKING;		public static const PAUSED		:String = VideoState.PAUSED;				private var videoPlayer			:FLVPlaybackDispose;		private var staticImage			:PhotoViewer;				// stage instances		public var videoControls		:VideoControls;		public var video_holder			:MovieClip;		public var videoPlayerCaption	:*;		public var bufferingBar			:Sprite;		public var paused_mc			:MovieClip		private var autoplay			:Boolean = true;		private var videoControlY		:Number;		private var lastVideoFLV		:String;		private var mouseIsOver			:Boolean = false;		private var box					:Box;		private var showCaptions		:Boolean = false;				private var pre_seek_playing	:Boolean = false;				private var cuePointArray		:Array;				function VideoPlayerCombo()		{			init();			addListeners();		}				private function init():void 		{								if (videoControls.caption_button != null){				// get caption state from shared object				var so:SharedObject = SharedObject.getLocal("vplayer_caption");				if (so.data.captionEnabled != undefined){					showCaptions = so.data.captionEnabled;					if (showCaptions) videoControls.captionToggle() 				}			}						if (ExternalInterface.available){				// figure out abolute path to html page (stupid relative path problem with flv)				browserURL = ExternalInterface.call('window.location.href.toString');				var urlSplit:Array = browserURL.split("#")				var lastSlash:int = urlSplit[0].lastIndexOf("/")				browserURL = urlSplit[0].slice(0, lastSlash+1)			} else {				browserURL = ""			}								trace("[VideoPlayer] creating videoPlayer")			videoPlayer = new FLVPlaybackDispose();			videoPlayer.skin = null			videoPlayer.scaleMode = VideoScaleMode.MAINTAIN_ASPECT_RATIO;			videoPlayer.activeVideoPlayerIndex = 1;			videoPlayer.visibleVideoPlayerIndex = 1			videoPlayer.autoRewind = true;						// component controls			if (videoControls.volume_btn != null)				videoPlayer.muteButton = videoControls.volume_btn;			if (videoControls.fullscreen_btn != null)				videoPlayer.fullScreenButton = videoControls.fullscreen_btn;			if (bufferingBar != null){				videoPlayer.bufferingBar = bufferingBar;				bufferingBar.visible = false;			}			//if (videoControls.playpause_btn != null)				//videoPlayer.playPauseButton	= videoControls.playpause_btn;			if (paused_mc != null){				paused_mc.visible = false				paused_mc.mouseChildren = false				paused_mc.mouseEnabled = false			}									videoPlayer.fullScreenTakeOver = false;			video_holder.addChild(videoPlayer);						cuePointArray = new Array();						// default size will be size of the holder			videoPlayer.setSize(video_holder.width, video_holder.height)					}				private function addListeners():void 		{			videoPlayer.addEventListener(VideoEvent.PLAYHEAD_UPDATE, handleVideoUpdate, false, 0, true);			videoPlayer.addEventListener(VideoEvent.COMPLETE, videoDone,false,0,true);			videoPlayer.addEventListener(VideoEvent.SEEKED, videoSeeked,false,0,true);			videoPlayer.addEventListener(VideoEvent.READY, videoReady,false,0,true);			videoPlayer.addEventListener(VideoProgressEvent.PROGRESS, videoProgress,false,0,true);			videoPlayer.addEventListener(MetadataEvent.CUE_POINT, handleCuePoint,false,0,true);			videoPlayer.addEventListener(MetadataEvent.METADATA_RECEIVED, handleMetaData,false,0,true);			//videoPlayer.addEventListener(VideoEvent.READY, handleReady,false,0,true);			videoPlayer.addEventListener(VideoEvent.STATE_CHANGE, handleVideoState,false,0,true);						video_holder.addEventListener(MouseEvent.CLICK, handleVideoClick,false,0,true);				this.addEventListener(MouseEvent.ROLL_OVER, handleMouseOver,false,0,true);				this.addEventListener(MouseEvent.ROLL_OUT, handleMouseOut,false,0,true);							if (videoControls.caption_button != null){				videoControls.caption_button.addEventListener(MouseEvent.CLICK, handleCaptionButtonClick, false, 0, true)			}						videoControls.addEventListener(VideoControlsEvent.PLAY, handleVideoControl, false, 0, true)			videoControls.addEventListener(VideoControlsEvent.PAUSE, handleVideoControl, false, 0, true)						if (videoControls.hasSeekBar){				videoControls.addEventListener(VideoControlsEvent.SCRUB_STARTED, handleSeekDown, false, 0, true)				videoControls.addEventListener(VideoControlsEvent.SCRUB_STOPPED, handleSeekUp, false, 0, true)				videoControls.addEventListener(VideoControlsEvent.SCRUB_UPDATE, handleScrub, false, 0, true);			}		}				//_______________________________________________________________________________________________________________________INPUT						public function scaleVideo(adjust:Boolean):void 		{			if (adjust){				videoPlayer.scaleMode = VideoScaleMode.MAINTAIN_ASPECT_RATIO;					} else {				videoPlayer.scaleMode = VideoScaleMode.	NO_SCALE;			}		}						public function getVideoComponent():FLVPlaybackDispose		{			return videoPlayer;		}						private var captionConfigured:Boolean = false;		private var videoCaptionSource:String = ""		private var captionTextField:TextField		public function captionSource(val:String, captionBox_txt:TextField = null):void 		{			//killCaptionComponent() // deletes caption component if exists			captionConfigured = false			videoCaptionSource = val			captionTextField = captionBox_txt			TextHelper.formatHTML(captionTextField)			captionTextField.text = "";		}								private function setStaticImage(val:String):void 		{			staticImage = new PhotoViewer(val)			staticImage.setSize(w, h)			video_holder.addChild(staticImage)		}				public function set autoHide(val:Boolean):void 		{			videoControls.autoHide = val		}				public function get autoHide():Boolean 		{			return videoControls.autoHide;		}				public function set autoPlay(val:Boolean):void 		{			autoplay = val;		}				private var videoToLoad:String		private var videoProcessed:Boolean = false		private var videoStreamClosed:Boolean = true		// saves video path so when playa button is clicked will load		// loads static images		public function loadVideo(flv:String, _static:String = null):void 		{			if (videoPlayerCaption != null)			 	videoPlayerCaption.showCaptions = false						videoToLoad = browserURL + flv;						if (videoControls.hasSeekBar){				videoControls.seekbar_mc.setValue(0);			}						if (videoControls.hasOwnProperty("setTime"))				videoControls.setTime(0, 0)						if (lastVideoFLV == flv){				// reset cue points				if (staticImage != null) staticImage.visible = true				while(cuePointArray.length > 0){					trace("removing cue point")					videoPlayer.removeASCuePoint(cuePointArray.shift().time);				}				if (autoplay){					videoPlayer.seek(0);				} else {					stopVideo()				}			} else{								if (lastVideoFLV != null){					//closeStream()				}								stopVideo()									videoProcessed = false				if (staticImage != null) staticImage.destroy()				if (_static != null) setStaticImage(_static)								videoControls.disable()								if (autoplay)					processVideo(videoToLoad)			}						lastVideoFLV = flv;						if (paused_mc != null){				paused_mc.visible = false			}						enableProgress = false // disable progress updating (stop laggy events)			videoControls.reset();											}				// loads video from server and plays when enough is buffered		private function processVideo(flv:String):void 		{			videoStreamClosed = false			videoProcessed = true			trace("[VideoPlayer] loading: '" + flv + "'");			videoPlayer.source =  flv;						//setup queuepoints			for (var i:int = 0; i< cuePointArray.length; i++){				videoPlayer.addASCuePoint(cuePointArray[i].time,cuePointArray[i].name)			}						videoPlayer.playWhenEnoughDownloaded()							if (videoCaptionSource != "")				setupCaptioning()											enableProgress = true		}				private function setupCaptioning():void 		{			// only create new if old one is null			if (videoPlayerCaption == null){				videoPlayerCaption = new FLVPlaybackCaptioning()				addChild(videoPlayerCaption)				//try{				videoPlayerCaption.autoLayout = true;				if (captionTextField != null){					captionTextField.text = ""					videoPlayerCaption.captionTarget = captionTextField;					captionTextField.mouseEnabled = false;				}				//videoPlayerCaption.addEventListener (CaptionChangeEvent.CAPTION_CHANGE, onCaptionChange, false, 0, true);				videoPlayerCaption.mouseEnabled = false;				videoPlayerCaption.mouseChildren = false;				videoPlayerCaption.simpleFormatting = true				videoPlayerCaption.videoPlayerIndex = 1				videoPlayerCaption.flvPlayback = videoPlayer;								//if (videoControls.caption_button != null)				videoPlayerCaption.captionButton = videoControls.caption_button							}									if (!showCaptions){				videoPlayerCaption.showCaptions = false			} else {				videoPlayerCaption.showCaptions = false				videoPlayerCaption.showCaptions = true			}						// assign the caption xml			videoPlayerCaption.source = videoCaptionSource;			captionConfigured = true					}				public function addCuePoint(_time, _name:String):void 		{			cuePointArray.push({time:_time, name:_name})			//videoPlayer.addASCuePoint(_time, _name)		}				public function playVideo():void 		{						//Debug.alert("click")						trace("[VideoPlayer] play");			if (videoProcessed){				//Debug.alert("playing video")				videoPlayer.play();							} else {				//Debug.alert("not loaded, processing")				processVideo(videoToLoad)			}		}				public function pauseVideo():void 		{			try{				videoPlayer.pause();			} catch (err){}					}				public function stopVideo():void 		{			if (!videoProcessed) return									try{				videoPlayer.stop();			} catch (err){}					}				// scrub to time 		public function scrubTo(val:Number):void 		{						videoPlayer.seek(val);		}				public function setSize(_w, _h):void 		{			w = _w;			h = _h;			videoPlayer.setSize(w, h);			if (staticImage != null) staticImage.setSize(w, h)						if (bufferingBar != null){				bufferingBar.x = (_w / 2) + videoPlayer.x				bufferingBar.y = (_h / 2) + videoPlayer.y			}		}						private function showControls():void 		{			if (videoControls.autoHide)				TweenLite.to(videoControls, .5, {y:videoControlY});		}				private function hideControls():void 		{			if (videoControls.autoHide){				if (!mouseIsOver && videoPlayer.state == VideoState.PLAYING)					TweenLite.to(videoControls, .5, {y:videoControlY + videoControls.height});			}		}				public function moveControlsTo(spr:Sprite):void 		{			videoControls.y = 0;			videoControls.x = 0;			spr.addChild(videoControls);		}						//_______________________________________________________________________________________________________________________HANDLERS						private function handleCaptionButtonClick(e:MouseEvent):void 		{			if (videoPlayerCaption == null){				// videoplayercaption not installed yet				showCaptions = videoControls.captionToggle()			}  else {							showCaptions = videoPlayerCaption.showCaptions			}									var so:SharedObject = SharedObject.getLocal("vplayer_caption");			//trace("Current SharedObject size is " + so.size + " bytes.");			so.data.captionEnabled = showCaptions			so.flush();					}				//private function onCaptionChange(e:CaptionChangeEvent):void 		//{			//Debug.alert("test")					//}				private function handleMouseOver(e:MouseEvent):void 		{			mouseIsOver = true;			showControls();		}				private function handleMouseOut(e:MouseEvent):void 		{			mouseIsOver = false;			hideControls();		}				private function handleVideoClick(e:MouseEvent):void 		{			if (videoPlayer.playing){				pauseVideo()			} else if (videoPlayer.paused || videoPlayer.stopped){				playVideo()			}		}						// changes in video state		private function handleVideoState(e:VideoEvent):void 		{			switch(e.state) {								case VideoState.PLAYING:					videoControls.showPlayButton(false)					if (staticImage != null)						staticImage.visible = false;					hideControls();					if (paused_mc != null){						paused_mc.visible = false					}					break;				case VideoState.PAUSED:					videoControls.showPlayButton(true)					showControls();					if (paused_mc != null){						paused_mc.visible = true					}					break;				case VideoState.STOPPED:					videoControls.showPlayButton(true)					showControls();					if (staticImage != null)						staticImage.visible = true;					break;								}		}				private function videoDone(e:VideoEvent):void 		{			trace("[VideoPlayer] video done")			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.DONE));		}				private function handleReady(e:VideoEvent):void 		{			trace("[VideoPlayer] video ready")			//if (videoPlayerCaption != null)										}				private var enableProgress:Boolean = true		private function videoProgress(e:VideoProgressEvent):void 		{						//if (!enableProgress) return;						var percent:Number = e.bytesLoaded / e.bytesTotal;			videoControls.seekbar_mc.setProgress(percent);		}						private function handleVideoUpdate(e:VideoEvent):void 		{			// update progress bar						if (videoControls.hasSeekBar){				var percent:Number = (e.playheadTime  / videoPlayer.totalTime);				videoControls.seekbar_mc.setValue(percent);			}						// update clock			//videoControls.time_txt.text = ConvertTime.secondsToMMSS(e.playheadTime) + "/" + ConvertTime.secondsToMMSS(videoPlayer.totalTime);			if (videoControls.hasOwnProperty("setTime"))				videoControls.setTime(e.playheadTime, videoPlayer.totalTime)						dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.UPDATE, {state:e.state, time:e.playheadTime}));		}				private function handleMetaData(e:MetadataEvent):void 		{			trace("---->" + e.info.keyframes);		}				private function videoSeeked(e:VideoEvent):void 		{			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.SEEK, {state:e.state, time:e.playheadTime}));		}				private function videoReady(e:VideoEvent):void 		{			videoControls.enable()			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.READY));		}				private function handleCuePoint(e:MetadataEvent):void 		{			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.CUE_POINT, {name:e.info.name}));		}				private function handleScrub(e:VideoControlsEvent ):void 		{			videoPlayer.seekPercent(e.parameters.value * 100)		}				private function handleSeekDown(e:VideoControlsEvent):void 		{			if (videoPlayer.state == VideoState.PLAYING){				pre_seek_playing = true				pauseVideo()			} else {				pre_seek_playing = false;			}		}								private function handleSeekUp(e:VideoControlsEvent):void 		{			TweenMax.killDelayedCallsTo(playVideo)			if (pre_seek_playing){				TweenMax.delayedCall(.5, playVideo)			}		}						private function handleVideoControl(e:VideoControlsEvent):void 		{			switch (e.type){				case VideoControlsEvent.PLAY:					playVideo()					break;				case VideoControlsEvent.PAUSE:					trace("pause video");					pauseVideo()					break;			}		}				/*public override function get height():Number		{			return videoPlayer.height			}				public override function get width():Number		{			return videoPlayer.width;		}		*/						public override function destroy():void 		{			stopVideo()						TweenMax.killDelayedCallsTo(playVideo)						videoPlayer.soundTransform = null						videoPlayer.removeEventListener(VideoEvent.PLAYHEAD_UPDATE, handleVideoUpdate);			videoPlayer.removeEventListener(VideoEvent.COMPLETE, videoDone);			videoPlayer.removeEventListener(VideoEvent.SEEKED, videoSeeked);			videoPlayer.removeEventListener(VideoEvent.READY, videoReady);			videoPlayer.removeEventListener(VideoProgressEvent.PROGRESS, videoProgress);			videoPlayer.removeEventListener(MetadataEvent.CUE_POINT, handleCuePoint);			videoPlayer.removeEventListener(MetadataEvent.METADATA_RECEIVED, handleMetaData);			//videoPlayer.removeEventListener(VideoEvent.READY, handleReady);			videoPlayer.removeEventListener(VideoEvent.STATE_CHANGE, handleVideoState);						video_holder.removeEventListener(MouseEvent.CLICK, handleVideoClick);				this.removeEventListener(MouseEvent.ROLL_OVER, handleMouseOver);				this.removeEventListener(MouseEvent.ROLL_OUT, handleMouseOut);							if (videoControls.caption_button != null)				videoControls.caption_button.removeEventListener(MouseEvent.CLICK, handleCaptionButtonClick)			videoControls.removeEventListener(VideoControlsEvent.PLAY, handleVideoControl)			videoControls.removeEventListener(VideoControlsEvent.PAUSE, handleVideoControl)						if (videoControls.hasSeekBar){				videoControls.removeEventListener(VideoControlsEvent.SCRUB_STARTED, handleSeekDown)				videoControls.removeEventListener(VideoControlsEvent.SCRUB_STOPPED, handleSeekUp)				videoControls.removeEventListener(VideoControlsEvent.SCRUB_UPDATE, handleScrub);			}									videoControls.destroy();								cuePointArray = null						killCaptionComponent()						if (staticImage != null){				staticImage.destroy()			}									FLVPlaybackDispose(videoPlayer).dispose();			video_holder.removeChild(videoPlayer)			//videoPlayer.destroy()			videoPlayer = null					}				private function closeStream():void 		{			try{				videoPlayer.closeVideoPlayer(1)			} catch(e:Error){}					}				public override function set soundTransform(value:SoundTransform):void		{			videoPlayer.soundTransform = value;		}				private function killCaptionComponent():void 		{			if (videoPlayerCaption != null){							//videoPlayerCaption.removeEventListener(CaptionChangeEvent.CAPTION_CHANGE, onCaptionChange); 				removeChild(videoPlayerCaption)				captionTextField = null;				videoPlayerCaption.source = null;				videoPlayerCaption = null;			}		}					}}