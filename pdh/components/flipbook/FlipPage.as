package pdh.components.flipbook{	import flash.filters.DropShadowFilter;	import flash.geom.*;	import flash.events.Event;	import flash.events.MouseEvent;	import pdh.util.PhotoViewer;	import pdh.events.PhotoViewerEvent;	import pdh.bitmap.BitmapTools;	import flash.display.*;	import gs.TweenMax;	import pdh.graphics.Box;	import pdh.events.FlipBookEvent;	public class FlipPage extends Sprite 	{		private var firstSlices					:Array=[];		private var secondSlices				:Array=[];		private var fLen						:Number=400;		private var picWidth					:Number=166;		private var picHeight					:Number=240;		private var isMoving					:Boolean=false;		private var spCard						:Sprite;		private var loadedPhotoArray			:Array;		private var curTheta					:Number		private var sliceWidth					:Number=1;		private var numSlices					:Number		private var spSide0						:Sprite		private var spSide1						:Sprite		private var bdFirst						:BitmapData		private var bdSecond					:BitmapData		function FlipPage(_dat:Array):void 		{			init(_dat);		}		private function init(_dat:Array):void 		{			loadPages(_dat)		}				private function loadPages(_dat:Array):void 		{			loadedPhotoArray = new Array()			for (var i:int = 0 ; i < _dat.length; i++){				var loader:PhotoViewer = new PhotoViewer(_dat[i].src)				loadedPhotoArray.push(loader);			}			loadedPhotoArray[_dat.length - 1].addEventListener(PhotoViewerEvent.LOADED, handlePhotosLoaded)		}				private function handlePhotosLoaded(e:PhotoViewerEvent):void 		{			dispatchEvent(new FlipBookEvent(FlipBookEvent.LOADED));			TweenMax.delayedCall(1 , build, [loadedPhotoArray[0], loadedPhotoArray[1] ])		}		private function build(bit1:PhotoViewer, bit2:PhotoViewer):void 		{			picWidth = bit1.width;			picHeight = bit1.height;			bdFirst = BitmapTools.getBitmapData(bit1)			bdSecond = BitmapTools.getBitmapData(bit2)						spCard =new Sprite();			this.addChild(spCard);						spSide0=new Sprite();			spCard.addChild(spSide0);			spSide1=new Sprite();			spCard.addChild(spSide1);						numSlices=picWidth/sliceWidth;						spSide0.filters = [ new DropShadowFilter() ];			spSide1.filters = [ new DropShadowFilter() ];			curTheta=0;			addListeners()			cutSlices();						renderView(curTheta);		}						private function addListeners():void 		{			spSide0.addEventListener(MouseEvent.CLICK,sideClicked);			spSide1.addEventListener(MouseEvent.CLICK,sideClicked);			this.addEventListener(Event.ENTER_FRAME,onEnter);		}		private function cutSlices():void 		{			var i:int;			for (i=0; i<numSlices-1; i++) {				firstSlices[i]=new Bitmap(new BitmapData(sliceWidth+1,picHeight));				firstSlices[i].bitmapData.copyPixels(bdFirst,new Rectangle(i*sliceWidth,0,sliceWidth+1,picHeight),new Point(0,0));				secondSlices[i]=new Bitmap(new BitmapData(sliceWidth+1,picHeight));				secondSlices[i].bitmapData.copyPixels(bdSecond,new Rectangle(i*sliceWidth,0,sliceWidth+1,picHeight),new Point(0,0));				spSide0.addChild(firstSlices[i]);				spSide1.addChild(secondSlices[i]);			}			firstSlices[numSlices-1]=new Bitmap(new BitmapData(sliceWidth,picHeight));			firstSlices[numSlices-1].bitmapData.copyPixels(bdFirst,new Rectangle((numSlices-1)*sliceWidth,0,sliceWidth,picHeight),new Point(0,0));			secondSlices[numSlices-1]=new Bitmap(new BitmapData(sliceWidth,picHeight));			secondSlices[numSlices-1].bitmapData.copyPixels(bdSecond,new Rectangle((numSlices-1)*sliceWidth,0,sliceWidth,picHeight),new Point(0,0));			spSide0.addChild(firstSlices[numSlices-1]);			spSide1.addChild(secondSlices[numSlices-1]);		}				private function renderView(t:Number):void 		{			var j:int;			var curv0:Array=[];			var curv1:Array=[];			var curv2:Array=[];			var curv3:Array=[];			var curNormal:Number;			var factor1:Number;			var factor2:Number;			var curTransMatrix:Matrix;			t=t*Math.PI/180;			curNormal=Math.cos(t);			if (curNormal>=0) {				for (j=0; j<numSlices; j++) {					firstSlices[j].visible=true;					secondSlices[j].visible=false;				}			} else {				for (j=0; j<numSlices; j++) {					firstSlices[j].visible=false;					secondSlices[j].visible=true;				}			}			for (j=0; j<numSlices; j++) {				factor1=fLen/(fLen-Math.sin(t)*(-picWidth/2+j*sliceWidth));				factor2=fLen/(fLen-Math.sin(t)*(-picWidth/2+(j+1)*sliceWidth));				curv0=[factor1*(-picWidth/2+j*sliceWidth)*Math.cos(t),-factor1*picHeight/2];				curv1=[factor2*(-picWidth/2+(j+1)*sliceWidth)*Math.cos(t),-factor2*picHeight/2];				curv2=[factor2*(-picWidth/2+(j+1)*sliceWidth)*Math.cos(t),factor2*picHeight/2];				curv3=[factor1*(-picWidth/2+j*sliceWidth)*Math.cos(t),factor1*picHeight/2];				curTransMatrix=calcMatrixForSides(curv0,curv1,curv2,curv3);				firstSlices[j].transform.matrix=curTransMatrix;			}			for (j=0; j<numSlices; j++) {				factor1=fLen/(fLen-Math.sin(t)*(picWidth/2-j*sliceWidth));				factor2=fLen/(fLen-Math.sin(t)*(picWidth/2-(j+1)*sliceWidth));				curv0=[factor1*(picWidth/2-j*sliceWidth)*Math.cos(t),-factor1*picHeight/2];				curv1=[factor2*(picWidth/2-(j+1)*sliceWidth)*Math.cos(t),-factor2*picHeight/2];				curv2=[factor2*(picWidth/2-(j+1)*sliceWidth)*Math.cos(t),factor2*picHeight/2];				curv3=[factor1*(picWidth/2-j*sliceWidth)*Math.cos(t),factor1*picHeight/2];				curTransMatrix=calcMatrixForSides(curv0,curv1,curv2,curv3);				secondSlices[j].transform.matrix=curTransMatrix;			}		}		private function calcMatrixForSides(v0:Array,v1:Array,v2:Array,v3:Array):Matrix		{			var curMatrix:Matrix;			var transMatrix:Matrix;			var v:Array=findVecMinusVec(v1,v0);			var w:Array=findVecMinusVec(v3,v0);			curMatrix=new Matrix(v[0]/sliceWidth,v[1]/sliceWidth,w[0]/picHeight,w[1]/picHeight);			transMatrix=new Matrix(1,0,0,1,v0[0],v0[1]);			curMatrix.concat(transMatrix);			return curMatrix;		}		private function findVecMinusVec(v:Array,w:Array):Array 		{			return [v[0]-w[0],v[1]-w[1],v[2]-w[2]];		}		private function sideClicked(e:MouseEvent):void 		{			if (isMoving==false) {				isMoving=true;			}		}				private function onEnter(e:Event):void 		{			if (isMoving) {				curTheta+=36;				curTheta=curTheta%360;				renderView(curTheta);				if ((curTheta%180)==0) {					isMoving=false;				}			}		}	}// end class}// end package