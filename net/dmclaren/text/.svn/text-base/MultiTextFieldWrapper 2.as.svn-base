package net.dmclaren.text{	import flash.display.Sprite;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.text.TextLineMetrics;	import flash.events.TextEvent;	import flash.events.Event;	/**	 * manages wrapping across multiple text fields	 *	 * @author Daniel McLaren (http://danielmclaren.net)	 */	public class MultiTextFieldWrapper	{		protected var _textFields:Array;		protected var _text:String;		protected var _htmlText:String;		protected var _remainder:String;				public function MultiTextFieldWrapper(textFields:Array=null):void		{			if (textFields == null) textFields = new Array();			_textFields = textFields;			_remainder = "";		}				/**		 * an ordered array of the TextField instances that will hold the text		 */		public function get textFields():Array		{			return _textFields;		}		public function set textFields(v:Array):void		{			_textFields = v;			refreshText();		}				/**		 * the text which is wrapped across the text fields, including		 * any remainder text which may not be visible		 */		public function get text():String		{			return _text;		}		public function set text(v:String):void		{			_htmlText = null;			_text = v;			refreshText();		}				public function set htmlText(v:String):void		{			_htmlText = v;			refreshText();		}				/**		 * returns the portion of text which was left over after		 * all the text fields were filled		 */		public function get remainder():String		{			return _remainder;		}				/**		 * recalculates the strings for each of the text fields.  this method can be		 * called to force a recalculation after TextFields have been resized.		 */		public function refreshText():void		{			var tf:TextField;			var i:uint;			var j:uint;						var htmlMode:Boolean = _htmlText != null;						for (i = 0; i < _textFields.length; i++)			{				tf = _textFields[i] as TextField;				tf.text = "";			}			_remainder = "";						if ((_text == "" || _text == null)				&& (_htmlText == "" || _htmlText == null))			{				return;			}						var remainder:String = htmlMode ? _htmlText : _text;			var currText:String = "";			var lastLineEndedPara:Boolean = true;						for (i = 0; i < _textFields.length; i++)			{				tf = _textFields[i] as TextField;								// First set the text for the field so we can find out where the				// line break will be in the last line of the field				if (htmlMode)				{					tf.htmlText = remainder;				}				else				{					tf.text = remainder;				}								// make sure we're scrolled to the first line				tf.scrollV = 1;								var charCount:int = 0;								//				// TODO:				//				// factor out the line counting method to a property.  each method has				// its advantages/disadvantages				//								// the following line is a version that occasionally has extra space at bottom				for (j = 0; j < tf.numLines - tf.maxScrollV + 1; j++)				// the following line is a version that occasionally scrolls on mouse drag or mousewheel				//for (j = 0; j < tf.bottomScrollV; j++) 				{					charCount += tf.getLineLength(j);				}								if (htmlMode)				{					tf.htmlText = remainder.slice(0,charCount);				}				else				{					tf.text = remainder.slice(0,charCount);				}				remainder = remainder.substr(charCount);								while (remainder.charAt(0) == '\n'					|| remainder.charAt(0) == '\r')				{					remainder = remainder.substr(1);				}			}			_remainder = remainder;		}	}}